{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation Wiki on CVs and how to use them","text":"<p>Documentation in progress</p> <p>The contents of the pages are currently in development and will change. </p> <p>Tasks before a functioning CV library. </p> <ul> <li>complete link checking (there are still some typos)</li> <li>automated issue template parser - convert the issues into pull requests. (rewrite)</li> <li>example notebooks</li> <li>update web browser, pages, and cmipld recursive functions including known edge cases. </li> <li>CMIP6 style, CMOR compatible CV generation</li> <li>project template for use by others. </li> </ul> <p>CV task team tasks. </p> <ul> <li>determine the optimum naming of keys</li> <li>clearly define the standards. </li> <li>develop a set of pydantic checks. </li> </ul>"},{"location":"repository_status/","title":"JSON-LD Status","text":"<p>Documentation in progress</p> <p>All repositories listed below are incomplete and works of progress. The status badges merely identify whether or not the files have sucessfully published to pages, and if the qc script has failed. </p> Repository GitHub Pages URL Repository URL Status Badge wcrp-universe https://wcrp-cmip.github.io/WCRP-universe/ repo-link mip-variables https://wcrp-cmip.github.io/MIP-variables/ repo-link cmip6plus https://wcrp-cmip.github.io/CMIP6Plus_CVs/ repo-link cmip7 https://wcrp-cmip.github.io/CMIP7_CVs/ repo-link cf https://wcrp-cmip.github.io/CF/ repo-link obs4mips https://wolfiex.github.io/obs4MIPs-cmor-tables-ld/ repo-link"},{"location":"CMIP-LD/Introduction/","title":"Introduction","text":""},{"location":"CMIP-LD/Introduction/#cmip-linked-data-utilities-library","title":"CMIP Linked Data utilities Library","text":"<p>In order to provide a set of directory utilities for creating, managing and interrogating the CVs the cmipld library was created. </p> <p></p>"},{"location":"CMIP-LD/Introduction/#contents","title":"Contents","text":"<p>The contents of these are as follows:</p> <ul> <li>actions : The location of a collection of reusable actions to be used in repository maintainance and LD processingJSON</li> <li>static : Visualisation templates and website functions and scripts</li> <li>notebook : a collection of example IPython Notebooks. </li> <li>frames : Example frames </li> <li>scripts : shell scripts installed with the cmipld library. Alternative functions using python can also be found within the setup.py file. </li> </ul>"},{"location":"Explore_the_data/Network/","title":"Network","text":""},{"location":"Explore_the_data/Network/#mycelium-the-universe-network","title":"Mycelium: The Universe Network","text":"<p>Since the inherent reason for selecting JSON-LD is its linked data component, it makes sense that we might want to explore the links and networks created between the repositories. </p> <p>To do this we can convert the full LD network into an RDF graph, and extract relevant information. We can take the different types of files and visualise the links between them, as well as recreating a network of each individual item and edge-bundling them for clarity. </p> <p>This method of visualisation can serve as a useful diagnostic in identifying errors in our files, and ensuring that there are no broken links within the system. </p> <p>To view a full screen version of the circle packing click here</p>"},{"location":"Explore_the_data/The_different_types/","title":"The different types","text":""},{"location":"Explore_the_data/The_different_types/#circle-packing-the-repositories","title":"Circle Packing the repositories.","text":"<p>The following bubble diagram shows the categories present in each directory. To explore, either 'click' on the circles, or hover over a group (cluster). </p> <p>To view a full screen version of the circle packing click here</p>"},{"location":"Explore_the_data/treemap/","title":"Treemap","text":""},{"location":"Explore_the_data/treemap/#treemap","title":"Treemap","text":"<p>This is a file size comparison of the JSON-LD files in all the registered repositories. </p> <p>In viewing the data this way, we can build a better understanding on the number of files, and their hierarchy. This can be helpful in identifying repositories which require more maintainance, or may not want to be downloaded in their entirety by the end user. </p> <p>To view a full screen version of the treemap click here</p>"},{"location":"Interact_with_the_data/%20_Introduction/","title":"Introduction","text":"<p>There are several available methods to interact with the JSONLD files.  Instructions on how to use these are found on each respective page within the sub menu. </p>"},{"location":"Interact_with_the_data/%20_Introduction/#methods-of-interaction","title":"Methods of interaction","text":"<p>The main categories are: </p>"},{"location":"Interact_with_the_data/%20_Introduction/#1-direct-interaction","title":"1. Direct interaction","text":"<p>Using the files locally or from the GitHub Repository. This can be done in a number of ways:  - local copy - github online interface - GET commands from a scripting language</p>"},{"location":"Interact_with_the_data/%20_Introduction/#2-cmipld-web-browsing-interface","title":"2. CMIPLD web browsing interface.","text":"<p>This is a rudementary JSONLD static page that can access all the JSONld files. This can be used to: - check file contents - view context  - perform framing requests - explore available files - quickly check entries using prefixes without the need for a full URL</p>"},{"location":"Interact_with_the_data/%20_Introduction/#3-pyld-native-python-interface","title":"3. PyLD native python interface.","text":"<p>This is the native library for interacting with JSONLD in python. This has the benefits of:  - Extracting files in Python - Framing  - Performing complex checks and incorporating the CVs in a personal workflow. </p>"},{"location":"Interact_with_the_data/%20_Introduction/#4-the-cmip-ld-cli","title":"4. The CMIP-LD CLI","text":"<p>A quick command line interface that allows dynamic JSON-LD file viewing in the terminal.  - performs recursive fills - allows the use of prefixes to easily access files - colapsable and coloured JSON exploration in the terminal  - outputs file contents or framing into a file. </p>"},{"location":"Interact_with_the_data/%20_Introduction/#5-cmip-ld-python-library","title":"5. CMIP-LD Python Library","text":"<p>A wrapper around PyLD with a number of useful tools and presets to ease the learning curve for non-technical and technical users.  - A list of registerd LD repositories.  - Can access and cross compare files both online and offline.  - Recursive file population (extracts all nested (linked) entries into your file) - Link Checker - LD Network generator.  - File Checker - Easy Framer and file simplifier. </p>"},{"location":"Interact_with_the_data/Command_line_interface/","title":"Command line interface","text":"<p>Screenshots and usage to go here. </p>"},{"location":"Interact_with_the_data/Command_line_interface/#installation","title":"Installation","text":"<p><pre><code>pip install git+https://github.com/WCRP-CMIP/CMIP-LD.git\n</code></pre> ! warning Beware that this repository is currently rapidly in development, and you will have to upgrade the installed version regularly. </p>"},{"location":"Interact_with_the_data/Command_line_interface/#arguments","title":"Arguments","text":"<p>The arguments can be found by typing <code>cmipld --help</code> once installed. These are:  <pre><code>CLI entry point for the JSON-LD processor. \nProcess JSON-LD documents and extract dependencies \n\nTo toggle between data and line mode, press 'm'. \nTo exit the viewer, press 'q'. Maintainer: Dan Ellis (CMIP IPO)\n\n\npositional arguments:\n    url                   URL of the JSON-LD document to process\n\noptions:\n    -h, --help            show this help message and exit\n    --deps, -d            Extract dependencies\n    --relative            Use relative URLs for dependencies\n    --no-compact, -nc     Do not compact the document\n    --expand-ctx, -ctx    Do not expand context\n    --no-expand-links, -nl\n                            Do not expand linked documents\n    --output OUTPUT, -o OUTPUT\n                            Output file (default: stdout)\n    --no-interactive, -n  Interactive Playground\n</code></pre></p>"},{"location":"Interact_with_the_data/Command_line_interface/#simple-use-case","title":"Simple use case.","text":"<p>The simplest use case is to view the url of a given file. The function recursively populates all the links if they exist. </p> <pre><code>cmipld universal:activity/cmip\n</code></pre> <p>This will give us in interactive view of the returned result. </p> <p></p>"},{"location":"Interact_with_the_data/Command_line_interface/#collapsing-entries","title":"Collapsing entries","text":"<p>Should we want to we can also scroll down and use the spacebar to collpse any fields we are not interested in. </p> <p></p>"},{"location":"Interact_with_the_data/Command_line_interface/#data-view","title":"Data View","text":"<p>For additional information we could also trigger the data view by pressing <code>m</code> to give us an alternative representation. </p> <p></p>"},{"location":"Interact_with_the_data/Command_line_interface/#quitting","title":"Quitting","text":"<p>To quit the viewer press <code>q</code>.</p>"},{"location":"Interact_with_the_data/Command_line_interface/#getting-all-the-dependancies","title":"Getting all the dependancies.","text":"<p>When opening a file, we get a small amount of additional information. For instance if we wish to open <code>cmip6plus:source/miroc6</code> we get a notification of the expansion of the prefix (to ensure this is correct) and a warning that one of the links does not appear to have resolved correctly. </p> <p></p>"},{"location":"Interact_with_the_data/Command_line_interface/#listing-all-the-links","title":"Listing all the links","text":"<p>To open all the links currently present in the JSONLD file we can use the <code>--deps</code> or <code>-d</code> flag when supplying our cli arguments. </p> <p></p>"},{"location":"Interact_with_the_data/Command_line_interface/#saving-the-output","title":"Saving the output","text":"<p>To save the output, we can use the <code>-o</code> flag with the location and filename we wish to save. E.g.  <pre><code>cmipld universal:activity/cmip -o cmip_activity.json\n</code></pre></p>"},{"location":"Interact_with_the_data/Command_line_interface/#rendering-all-items-in-a-directory","title":"Rendering all items in a directory","text":"<p>Sometimes we might want to view all the items in a repository of directory. For this reason we can use the graph.jsonld file. </p> <p>For instance entering: </p> <p><pre><code>cmipld universal:activity\n</code></pre> will resolve into  <pre><code>https://wcrp-cmip.github.io/WCRP-universe/activity/graph.jsonld\n</code></pre> which outlines all the files in the repository and displays them. </p> <p></p> <p>Optional extras to fix (these were working but changes in the code have rendered them temporarily disabled in the current version): Compact view.  Context Inclusion</p>"},{"location":"Interact_with_the_data/Direct_Interaction/","title":"Direct Interaction","text":""},{"location":"Interact_with_the_data/Direct_Interaction/#introduction","title":"Introduction","text":"<p>There are several available methods to interact with the JSONLD files. </p>"},{"location":"Interact_with_the_data/Direct_Interaction/#direct-interaction","title":"Direct interaction","text":"<p>As the files are valid JSON custom scripts can be used to interact with them directly.</p> Repository GitHub Pages URL Repository URL wcrp-universe https://wcrp-cmip.github.io/WCRP-universe/ repo-link mip-variables https://wcrp-cmip.github.io/MIP-variables/ repo-link cmip6plus https://wcrp-cmip.github.io/CMIP6Plus_CVs/ repo-link cmip7 https://wcrp-cmip.github.io/CMIP7_CVs/ repo-link cf https://wcrp-cmip.github.io/CF/ repo-link obs4mips https://wolfiex.github.io/obs4MIPs-cmor-tables-ld/ repo-link <p>This means that you can download a local copy with  <pre><code>git clone &lt;github repo url&gt;\n</code></pre> View them in the browser, or use the requests / GET api to download them directly. </p>"},{"location":"Interact_with_the_data/Direct_Interaction/#file-structure","title":"File structure","text":"<p>If using the github interface, you can navigate as normal. JSONLD files are currently located under the <code>src-data</code> directory in each repository. </p> <p>If the user should so wish, they are also served using github pages, under the same filepath excluding the term <code>src-data</code>. </p> <p>This means that the following activity page</p> <p> https://github.com/WCRP-CMIP/WCRP-universe/blob/main/src-data/activity/cmip.json </p> <p>becomes</p> <p> https://wcrp-cmip.github.io/WCRP-universe/activity/cmip.json</p> <p>where the <code>.json</code> is optional, but helps the browser open the file for viewing rather than downloading it. </p>"},{"location":"Interact_with_the_data/PyLD/","title":"PyLD","text":"<p>Python LD Notebooks to go in here. </p> <p>example usage</p>"},{"location":"Interact_with_the_data/cmipLD_web_viewer/","title":"cmipLD web viewer","text":"<p>A wireframe of the JSONLD viewer can be found at : </p> <p>https://wcrp-cmip.github.io/CMIP-LD/static/viewer/</p> <p>To test this out, we can enter the URI for a JSONLD file. E.g. for the CMIP activity we have have the ID: https://wcrp-cmip.github.io/WCRP-universe/activity/cmip</p>"},{"location":"Interact_with_the_data/cmipLD_web_viewer/#link-simplification","title":"Link simplification","text":"<p>Rather than remembering this whole link, we are also able to use the pre-defined prefix from the table before</p> Repository GitHub Pages URL Repository URL wcrp-universe https://wcrp-cmip.github.io/WCRP-universe/ repo-link mip-variables https://wcrp-cmip.github.io/MIP-variables/ repo-link cmip6plus https://wcrp-cmip.github.io/CMIP6Plus_CVs/ repo-link cmip7 https://wcrp-cmip.github.io/CMIP7_CVs/ repo-link cf https://wcrp-cmip.github.io/CF/ repo-link obs4mips https://wolfiex.github.io/obs4MIPs-cmor-tables-ld/ repo-link <p>This means that to get to the same page, we can now type </p> <pre><code>universal:activity/cmip\n</code></pre>"},{"location":"Interact_with_the_data/cmipLD_web_viewer/#getting-the-result","title":"Getting The result","text":"<p>The web interface will not present a compacted view of the JSONLD file requested as such. </p>"},{"location":"Interact_with_the_data/cmipLD_web_viewer/#framing","title":"Framing","text":"<p>Currently this option is disabled to a CORRS same origin policy, but this will soon be fixed. </p>"},{"location":"Repository_Structure_and_automations/Context/","title":"Context","text":"<p>Documentation in progress</p> <p>These need to be checked. </p>"},{"location":"Repository_Structure_and_automations/Context/#location","title":"Location","text":"<p>Within each repository, a <code>_context_</code> file is supplied. This is not only used to provide crucial information for the resolution of JSONLD files, but also tells the cmipld scripts which repositories to process. </p>"},{"location":"Repository_Structure_and_automations/Context/#content","title":"Content","text":"<p>The context provides additional information for the data inside a JSONLD file - particularly when it comes to the links. This is generally comprised of several sections. </p> <p>A sample context file is given below. </p> <pre><code>{\n    \"@context\": {\n                    // define the base and prefix adresses so that we do not have to specify these in the file\n                    \"@base\": \"https://wcrp-cmip.github.io/CMIP6Plus_CVs/\",\n                    \"@vocab\": \"https://wcrp-cmip.github.io/CMIP6Plus_CVs/\",\n\n                    // map id and type to @id and @type. This is done for legibility\n                    \"id\": \"@id\",\n                    \"type\": \"@type\",\n\n                    // add any external prefixes. \n                    \"cmip7\": \"https://wcrp-cmip.github.io/CMIP7_CVs/\",\n                    \"wcrp-universe\": \"https://wcrp-cmip.github.io/WCRP-universe/\"\n\n                    // define information for fields which may be linked. \n                    \"activity\": {\n                                    \"@context\": \"https://wcrp-cmip.github.io/WCRP-universe/activity/_context_\",\n                                    \"@type\": \"@id\",\n                            }\n    },\n\n    // framing options go here, e.g. expand all links\n    \"@embed\": \"@always\"\n}\n</code></pre>"},{"location":"Repository_Structure_and_automations/Context/#additional-uses","title":"Additional Uses","text":""},{"location":"Repository_Structure_and_automations/Context/#see-framing","title":"(see framing).","text":"<p>To minimise the number of files we use, the <code>_context_</code> file is also used to provide a simple framing example when processing the data. This is to make working with the data easier on the end user. </p>"},{"location":"Repository_Structure_and_automations/Context/#see-schema","title":"(see schema)","text":"<p>The context file is also used to update the schema when fetching information from alternative locations. </p>"},{"location":"Repository_Structure_and_automations/Issue_templates/","title":"Issue templates","text":"<p>As mentioned in Schema the generation of issue templates has been automated:</p>"},{"location":"Repository_Structure_and_automations/Issue_templates/#creating-github-issue-templates-a-simple-guide","title":"Creating GitHub Issue Templates: A Simple Guide","text":"<p>The process of generating GitHub issue templates is like creating a smart, automated form-maker. Here's how it works:</p>"},{"location":"Repository_Structure_and_automations/Issue_templates/#updating-the-schema","title":"Updating the Schema","text":"<p>Much like JSON-LD it is possible to reference other JSON Schema fields using resolvable URL links. Using the context, we are able to locate the relevant <code>_schema_</code> files in other repositories, and extract and up to date list of permissable files (ie ones that do not break the links)</p> <pre><code>graph TD\n    A[Start: Load Schema and Context] --&gt; B[Check Directory Contents]\n    B --&gt;|Valid Directory| C[Load JSON Files]\n    C --&gt; D[Populate 'contains' Enum with JSON Filenames]\n    C --&gt; E[Process Context Definitions]\n    E --&gt; F[Update Context-based References]\n    F --&gt; G[Modify Schema Properties with Linked Descriptions]\n    G --&gt; H[Update Base Reference URL]\n    H --&gt; I[Write Updated Schema to File]\n    I --&gt; J[End]\n    B --&gt;|No _context_ or _schema_ files| J\n</code></pre>"},{"location":"Repository_Structure_and_automations/Issue_templates/#building-the-template","title":"Building the Template","text":"<p>Now we have an up to date and valid description (schema), it we want to turn it into a GitHub-friendly issue template. To do this we can use the types defined in the schema to decides what type of input is needed: text boxes, dropdowns, checkboxes etc. </p> <p>Creating the Template</p>"},{"location":"Repository_Structure_and_automations/Issue_templates/#schema-update-workflow","title":"Schema Update Workflow","text":"<pre><code>graph TD\n    A[Start: Load Schema] --&gt; B[Expand Schema with $ref Resolution]\n    B --&gt; C[Extract Properties]\n    C --&gt; D[Generate Markdown Table for Enum Fields]\n    C --&gt; E[Create Form Fields]\n    E --&gt; F[Dropdown for Enum Fields]\n    E --&gt; G[Checkboxes for Array of Enums]\n    E --&gt; H[Input for Default Fields]\n    E --&gt; I[Dropdown for Booleans]\n    F --&gt; J[Append Field to Form Body]\n    G --&gt; J\n    H --&gt; J\n    I --&gt; J\n    J --&gt; K[Output GitHub Issue Template]\n    K --&gt; L[Save Template to File]\n    L --&gt; M[End]</code></pre> <p>All generated templates are saved in the <code>.github/ISSUE_TEMPLATES</code> folder. From here github knows to offer the selection of newly generated forms to anyone wishing to submit a new item to the repository. </p> <p>An example google issue form generated by the YAML file: </p>"},{"location":"Repository_Structure_and_automations/Issue_templates/#special-fields","title":"Special Fields","text":"<p>We have added a few additional fields to the schema to ensure that it can be used for template generation. These are: </p>"},{"location":"Repository_Structure_and_automations/Issue_templates/#additional-work","title":"Additional work","text":"<p>In addition to the following we also need to run the 'create_labels' script from cmiplld in order for the designated labels to be available for each issue. </p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/","title":"A new submission story.","text":"<p>In this section we outline the processing which happens in the background when a user supplies new information into the CVs. As a case study we shall explore what happens when we submit a new institution in the universal repository. </p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#issue-submission-form","title":"Issue Submission Form","text":"<p>The process starts with the submission of the relevant data. For this a user must find the relevant repository of the CVs provide all the required information to create such an entry. </p> <p>There are two planned routes for entering the required data:      - Github issue form     - Dynamic website form</p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#github-form","title":"GitHub form","text":"<p>Github issue templates can be used to guide input in the form of markdown files. More recently the option to use a yml file to create a form has been added. Using this we define an input form with relevant descriptions which once filled creates a formatted issue. </p> <p>For more information on the syntax click here</p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#where-are-the-issue-forms","title":"Where are the issue forms?","text":"<p>Issue forms reside in the <code>.workflows/ISSUE_TEMPLATE/</code> directory. Here we explore the structure of the <code>add_institution.yml</code> template. The structure of this is described below: </p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#issue-labels","title":"Issue Labels","text":"<p>Exploring the source code we can assign automatic labels for when the issue is created:  <pre><code>labels:\n    - alpha\n    - institution\n</code></pre></p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#markdown","title":"Markdown","text":"<p>We also add a short markdown description  <pre><code>-   type: markdown\n    attributes:\n        value: |\n            ####\n            ## Adding a new Institution. \n\n            Please fill in the information below. \n</code></pre></p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#dropdown","title":"Dropdown","text":"<p>And a dropdown to define what kind of action is required by the processing script. (Note although it is possible to determine this using labels, there are cases where conflicting labels may be used to identify issues that span several areas of interest, and therefore this is a more explicit method to do this.)</p> <pre><code>-   type: dropdown\n    id: category\n    attributes:\n        label: \"Issue Type\"\n        #   description: \"This is pre-set and cannot be changed.\"\n        options:\n            - \"institution\"\n        default: 0\n    validations:\n        required: true\n</code></pre> <p>As this is a required value, it is also set to auto-populate with the first (0th) item. If we had an entry which could be added or modified, there may be multiple options within the issue type category selection. </p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#inputs","title":"Inputs","text":"<p>Finally we define a set of inputs giving them a label, description in markdown, example text and whether or not the input is required for form submission. Unfortunately no further validation is possible within the github forms, and has to be carried out within the action described below. </p> <pre><code>-   id: label\n    attributes:\n        label: Acronym\n        description: |\n            A short acronym from which your institution can be identified with. \n\n            Note: This name must be unique across all organisations and cannot be changed once data is published with it.\n        placeholder: 'e.g., UoYork, MOHC, CMIP-IPO'\n    validations:\n        required: true\n    type: input\n</code></pre>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#dynamic-web-form","title":"Dynamic Web-Form","text":"<p>Although not currently available, the future plans is to replicate the web form on the mipcvs.dev server. This will constitute a fastAPI server which can access the suitability of a field as it is being entered. This will mean that any errors are flagged during entry, and do not require a review, edit, test loop. The end result from the website will still be the creation of a new issue, which upon submission triggers the same post-processing functions. </p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#submitting-a-new-issue","title":"Submitting a new issue","text":"<p>To submit a new form we start by going to the Issues tab on github.  If our template yml file is correctly formatted we should be able to select if from the list of available templates. </p> <p></p> <p>From here we are able open the relevant form, completing any required fields. </p> <p></p> <p>On submission, the pre-allocated labels are appended:</p> <p></p> <p>and the form content saved as the main issue. </p> <p></p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#workflow","title":"Workflow","text":"<p>When an issue is created or changed, we want to be able to run a series of scripts. These are called workflows. A workflow is defined in <code>.github/workflows</code>, with the components of the issue specific workflow new_issue.yml being outlined below. </p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#workflow-content","title":"Workflow content","text":""},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#triggers","title":"Triggers","text":"<p>The on section of a workflow outlines when an issue is run. Common triggers are on push, issue opened/closed, cron and dispatch.  <pre><code>on:\n  issues:\n    types: [opened, edited]\n</code></pre></p> <p>This means that should a submission need to be edited, the checks will run again until the relevant sections pass or the issue is closed. </p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#permissions","title":"Permissions","text":"<p>For workflows which need to interact with the repository, we need to define what the action is allowed to do. In this case, we can change the issue, repository content and create a pull request.  <pre><code>permissions:\n  issues: write\n  contents: write\n  id-token: write\n  pull-requests: write\n</code></pre></p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#jobs","title":"Jobs","text":"<p>The next section defines the scripts which run.  Instead of duplicating the same processing scripts in every repository we make use of reusable actions. These are modular workflows that work like functions, and can be located in a separate repository. </p> <pre><code>    steps:\n      - name: Run the parser on a new issue\n        id: new-issue-action\n        uses: WCRP-CMIP/CMIP-LD/actions/new-issue@main\n</code></pre>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#reusable-actions","title":"Reusable Actions.","text":"<p>The reusable action is located as part of the CMIP-LD repository. </p> <p>Here the action begins by installing the cmipld python library <pre><code>    - name: cmip-ld library\n        id: install-cmipld\n        uses: WCRP-CMIP/CMIP-LD/actions/cmipld@main\n</code></pre> We then checkout the repository, and run a set of python scripts. As the python scripts will need to access the issue submitter, its contents and id, we define this in the environmental variables. Finally we run the command line script <code>new_issue</code> as defined in the cmipld library.  </p> <pre><code>      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Run Python script\n        id: run_python\n        env:\n          ISSUE_TITLE: ${{ github.event.issue.title }}\n          ISSUE_BODY: |\n              ${{ github.event.issue.body }}\n          ISSUE_SUBMITTER: ${{ github.event.issue.user.login }}\n          ISSUE_NUMBER: ${{ github.event.issue.number }}\n          GH_TOKEN: ${{ github.token }}\n          GITHUB_TOKEN: ${{ github.token }} # We need this to update the issue\n\n        run: |\n          new_issue\n</code></pre>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#cmipld-command-line-scripts","title":"CMIPLD command line scripts.","text":"<p>When installing a python package, we are able to define entry-points. These are python functions which can be run as command line scripts. For example the <code>new_issue</code> command executes the <code>main</code> function from <code>cmipld.generate.new_issue</code>. </p> <p>This starts by parsing the issue content:  <pre><code>issue = get_issue()\nparsed_issue = parse_issue_body(issue['body'])\n</code></pre></p> <p>We then use the issue_type category field to determine what script to run, and load it <pre><code>issue_type = parsed_issue.get('issue_type', '')\nscript_path = f\"{path}{issue_type}.py\"\n\nspec = importlib.util.spec_from_file_location(issue_type, script_path)\nmodule = importlib.util.module_from_spec(spec)\nspec.loader.exec_module(module)\n</code></pre></p> <p>Finally we execute the <code>run</code> function of the newly imported module and provide it with the issue content, and respective number.  <pre><code>module.run(parsed_issue,issue)\n</code></pre></p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#issue-specific-script-processing","title":"Issue specific script: Processing","text":"<p>The scripts for each issue will be placed in the <code>.github/ISSUE_SCRIPT/</code> directory and will have the same name as the issue_type (see above). </p> <pre><code>import sys\nfrom pathlib import Path\nimport update_ror\nimport json, os\nfrom cmipld.utils import git\nfrom cmipld.tests import jsonld as tests\nfrom cmipld.tests.jsonld.organisation import ror\n\npath = './src-data/organisation/'\n\ndef similarity(name1, name2):\n    from difflib import SequenceMatcher\n    matcher = SequenceMatcher(None, name1, name2)\n    similarity = matcher.ratio() * 100\n    return similarity\n\ndef run(issue, packet):\n    git.update_summary(f\"## Issue content\\n ```json\\n{json.dumps(issue, indent=4)}\\n```\")\n    ror = issue['ror']\n    acronym = issue['acronym']\n    id = acronym.lower()\n    title = f'{issue[\"issue_type\"].capitalize()}_{acronym}'\n    git.update_issue_title(title)\n    git.newbranch(title)\n    acronym_test = tests.field_test(tests.components.id.id_field)\n    ror_test = tests.field_test(tests.organisation.ror.ror_field)\n\n    if ror != 'pending':\n        tests.run_checks(acronym_test, {\"id\": id})\n        tests.run_checks(ror_test, {\"ror\": ror})\n        data = update_ror.get_institution(ror, acronym)\n        ranking = similarity(issue['full_name_of_the_organisation'], data['long_label'])\n        git.update_summary(f\"## Similarity\\nThe similarity between the full name ({issue['full_name_of_the_organisation']}) of the organisation and the long label ({data['long_label']}) is {ranking}%\")\n        if ranking &lt; 80:\n            git.update_issue(f\"Warning: The similarity between the full name of the organisation and the long label is {ranking}%\")\n    else:\n        tests.run_checks(acronym_test, {\"id\": id})\n        data = {\n            \"id\": f\"{id}\",\n            \"type\": ['wcrp:organisation', f'wcrp:{issue[\"issue_type\"]}', 'universal'],\n            \"label\": acronym,\n        }\n    git.update_summary(f\"## Data content\\n ```json\\n{json.dumps(data, indent=4)}\\n```\")\n    outfile = path + id + '.json'\n    json.dump(data, open(outfile, 'w'), indent=4)\n    if 'submitter' in issue:\n        os.environ['OVERRIDE_AUTHOR'] = issue['submitter']\n    author = os.environ.get('OVERRIDE_AUTHOR')\n    git.commit_one(outfile, author, comment=f'New entry {acronym} in {issue[\"issue_type\"]} files.', branch=title)\n    git.newpull(title, author, json.dumps(issue, indent=4), title, os.environ['ISSUE_NUMBER'])\n</code></pre> <p>The pull request is also linked to the issue, allowing it to be closed on merge.  </p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#action-output","title":"Action output.","text":"<p>It is possible to view the status of the action under the actions tab in GitHub. Here we can select the relevant action, view what has been run, and the console output from this (should an error occur). </p> <p>Additionally when opening a specific action, the action summary has been updated to provide an update of what has been done. An example of this can be seen below. </p> <p></p>"},{"location":"Repository_Structure_and_automations/New_Data_Workflow/#quick-summary-of-the-submission-process","title":"Quick summary of the submission process","text":"<pre><code>graph TB\n  A[Run Script] --&gt; B[Update Summary: Issue Content]\n  B --&gt; C[Update Issue Title and Create Branch]\n  C --&gt; D[Run Checks]\n  D --&gt; E[Update Summary: Data Content]\n  E --&gt; F[Write Data to File]\n  F --&gt; G[Commit Changes]\n  G --&gt; H[Create Pull Request]</code></pre>"},{"location":"Repository_Structure_and_automations/Processing_functions/","title":"Processing functions","text":"<p>Documentation in progress</p> <p>These need to be checked. </p>"},{"location":"Repository_Structure_and_automations/Schema/","title":"Schema","text":"<p>Documentation in progress</p> <p>The schemas for each type still need to be defined.  For more rigorous checking of the contexts, Pydantic is used.  </p> <p>JSON-schema is a method of validating the data presented within a JSON format. It is used to run CI checking of the data, as well as providing some additional features. Since JSON-LD is also valid JSON, all these checks should run as expected.   </p>"},{"location":"Repository_Structure_and_automations/Schema/#validating-json-ld-files","title":"Validating json-ld files","text":"<p>To validate a file using the schema, we can run the following. </p> <pre><code>from cmipld.schema import validate\nimport requests\n\nbase = 'https://wcrp-cmip.github.io/WCRP-universe/activity/'\n\ndata = requests.get(f'{base}cmip').json()\nschema = requests.get(f'{base}_schema_').json()\n\nassert validate(data,schema)\n</code></pre> <p>Alternatively there is also a pytest written to iteratively perform this function.  (To be inserted here at a later point.)</p>"},{"location":"Repository_Structure_and_automations/Schema/#issue-templates","title":"Issue templates","text":"<p>Another use for the _schema_ file is that we can use it to build an issue form for the submission or modification of existing data.  Here the <code>_context_</code> is used to create dropdown or checkbox items that need to be linked, and the schema defines additional information on which fields are optional or required. </p> <p>Once the issues templates are populated, a github action will process the results, update the issue, modify the relevant files and create a pull request for review by the community. </p> <pre><code>flowchart TD\n    A[_schema_ file] --&gt;|Defines required/optional fields| B[Issue Form]\n    B --&gt;|Uses _context_ for dropdown/checkbox items| C[Populated Issue Templates]\n    C --&gt;|Triggered by submission| D[GitHub Action]\n    D --&gt;|Processes results| E[Updates Issue]\n    D --&gt;|Modifies relevant files| F[File Modification]\n    D --&gt;|Creates pull request| G[Pull Request]\n    F --&gt; G\n    G --&gt;|Reviewed by community| H[Final Approval]</code></pre> <p>For more information visit the Issue Templates Page</p>"},{"location":"Repository_Structure_and_automations/Schema/#restful-esque-description-of-repository-contents","title":"Restful-esque description of repository contents","text":"<p>Although the current files are statically hosted using GitHub pages, we are still able to produce a description of the repository, its contents and the various fields in the json-ld files. </p> <p>To accomplish this we leverage the use of JavaScript with the automatic 404 - not found page. Here we are able to check of a directory exists, and what it contains by examining the <code>_context_</code> and <code>_schema_</code> files. This is then used to produce a summary of the repository contents, links, and field types for the json ld.</p> <p>(examples to be added here. )</p>"},{"location":"Repository_Structure_and_automations/Github_Actions/JSONLD_update/","title":"JSONLD update","text":""},{"location":"Repository_Structure_and_automations/Github_Actions/JSONLD_update/#github-actions-for-jsonld-related-repositories","title":"GitHub Actions for JSONLD related repositories","text":""},{"location":"Repository_Structure_and_automations/Github_Actions/JSONLD_update/#overview","title":"Overview","text":"<p>The repositories utilise GitHub Actions for continuous integration and deployment. The main workflow identified is named \"Update JSONLD.\"</p>"},{"location":"Repository_Structure_and_automations/Github_Actions/JSONLD_update/#workflow-description","title":"Workflow Description","text":"<ul> <li>Name: Update JSONLD</li> <li>Purpose: This workflow is designed to update JSONLD files within the repository.</li> <li>Conditions: The workflow triggers on specific events such as commits, pull requests, or schedule (based on the standard GitHub Actions triggers).</li> </ul>"},{"location":"Repository_Structure_and_automations/Github_Actions/JSONLD_update/#key-steps-and-inputs","title":"Key Steps and Inputs","text":"<ol> <li>Checkout Repository:</li> <li>Action: <code>actions/checkout@v4</code></li> <li>Inputs: <ul> <li><code>fetch-depth: 2</code></li> <li><code>repository: wolfiex/obs4MIPs-cmor-tables-ld</code></li> </ul> </li> <li> <p>Description: Clones the repository with a depth of 2 to the runner.</p> </li> <li> <p>Install Dependencies:</p> </li> <li>Action: <code>pip install</code></li> <li>Inputs: <ul> <li>Various Python dependencies such as <code>pytest</code>, <code>cmip-ld</code>, etc.</li> </ul> </li> <li> <p>Description: Installs necessary Python packages for the workflow.</p> </li> <li> <p>Run Scripts:</p> </li> <li>Action: Custom scripts (e.g., <code>write_ancillary_C3S-GTO-ECV.py</code>, <code>obs4MIPsLib.py</code>)</li> <li>Inputs: <ul> <li>Specific scripts and their associated parameters.</li> </ul> </li> <li>Description: Executes scripts to process data, update files, or perform other tasks.</li> </ol>"},{"location":"Repository_Structure_and_automations/Github_Actions/JSONLD_update/#mermaid-diagrams","title":"Mermaid Diagrams","text":""},{"location":"Repository_Structure_and_automations/Github_Actions/JSONLD_update/#workflow-diagram","title":"Workflow Diagram","text":"<pre><code>graph TD\n    A[Start] --&gt; B[actions/checkout@v4]\n    B --&gt; C[pip install dependencies]\n    C --&gt; D[Run custom scripts]\n    D --&gt; E[End]</code></pre>"},{"location":"Repository_Structure_and_automations/Github_Actions/JSONLD_update/#detailed-step-diagram","title":"Detailed Step Diagram","text":"<pre><code>graph TD\n    A[Start] --&gt; B[actions/checkout@v4]\n    B --&gt; C1[fetch-depth: 2]\n    B --&gt; C2[repository]\n    C1 --&gt; D[pip install dependencies]\n    C2 --&gt; D\n    D --&gt; E1[Install pytest]\n    D --&gt; E2[Install cmip-ld]\n    F[Run custom scripts]\n    F --&gt; G1[script1.py]\n    F --&gt; G2[script2.py]\n    E1 --&gt; F\n    E2 --&gt; F\n    G1 --&gt; H[Trigger Publish Workflow]\n    G2 --&gt; H\n    H --&gt; I[End]</code></pre>"},{"location":"What_is_JSONLD%3F/Background/","title":"Background","text":""},{"location":"What_is_JSONLD%3F/Background/#json-linked-data","title":"JSON Linked-Data","text":"<p>JSONLD is a lightweight link data format closely conforming to the JSON standards. It allows us to provide relational data, in a flat format accessible to everyone within minimal intervention. </p>"},{"location":"What_is_JSONLD%3F/Background/#why-is-this-useful","title":"Why is this useful?","text":"<p>The JavaScript Object Notation has been accepted as a human and machine readable and intuitive data standard for both scripting and online programs. It tends to describe items in a Key-Value pair structure and present it in plain-text.  This is the standard that was adopted for CMIP6 control variables and has been used since. </p> <p>In converting current and future data into JSONLD we are able to provide pointers to reusable bits of information, thus drastically reducing duplication, and in turn human-induced error in the WCRP (and beyond) community. </p>"},{"location":"What_is_JSONLD%3F/Background/#existing-workflows","title":"Existing Workflows","text":"<p>In introducing any new technology, there is often a period in which existing software will need to be updated. By opting for JSONLD the interference between this should be minimal, since any produced files will still be readable by existing scripts. </p>"},{"location":"What_is_JSONLD%3F/Background/#bespoke-output-and-breaking-changes","title":"Bespoke output and Breaking Changes","text":"<p>The main merit of JSONLD comes from its framing capabilities. It allows us to take a flat JSON file and build (populate) this with all linked components without having to store them in the same file, or even location.  JSONLD parsers are available for all majour programming languages, and capable of extracting linked files (using their ids (URIs)) meaning that we will always have an up-to-date frame when we request it. </p> <p>This also means that should a non-standard or altered format be required for your work (e.g. just the names of MIPs or Institutions in an Activity, this will be possible through either custom framing or requesting an action be added to the relevant repository to generate this. Github actions are designed to run each time the data in the repository is updated. </p>"},{"location":"What_is_JSONLD%3F/Background/#how-does-it-change-the-existing-structure","title":"How does it change the existing structure?","text":"<p>JsonLD is still a valid JSON format allowing all previous tools and workflows to function. .  In addition to this we apply a intuitive unique id to each item, and a context file. </p>"},{"location":"What_is_JSONLD%3F/Background/#example-file-change-to-ld","title":"Example file change to LD","text":"<p><pre><code>{\n            \"description\": \"CMIP DECK: 1pctCO2, abrupt-4xCO2, amip, esm-piControl, esm-historical...\",\n            \"activity_id\": \"CMIP\",\n            \"url\": \"https://gmd.copernicus.org/articles/9/1937/2016/gmd-9-1937-2016.pdf\"\n}\n</code></pre> Is now updated to have an <code>id</code>, <code>type</code> and <code>@context</code></p> <pre><code>{\n            \"@context\": \"_context_\",\n            \"id\": \"cmip\",\n            \"type\": \"activity\",\n            \"description\": \"CMIP DECK: 1pctCO2, abrupt-4xCO2, amip, esm-piControl, esm-historical...\",\n            \"name\": \"CMIP\",\n            \"url\": \"https://gmd.copernicus.org/articles/9/1937/2016/gmd-9-1937-2016.pdf\"\n}\n</code></pre>"},{"location":"What_is_JSONLD%3F/Background/#context-files","title":"Context files","text":"<p>The context file defines how this shall be treated, where the files are located, and if there are any additional links to the fields. An example context file is given below <pre><code>{\n    \"@context\": {\n                    // define the base and prefix adresses so that we do not have to specify these in the file\n                    \"@base\": \"https://wcrp-cmip.github.io/CMIP6Plus_CVs/\",\n                    \"@vocab\": \"https://wcrp-cmip.github.io/CMIP6Plus_CVs/\",\n\n                    // map id and type to @id and @type. This is done for legibility\n                    \"id\": \"@id\",\n                    \"type\": \"@type\",\n\n                    // add any external prefixes. \n                    \"cmip7\": \"https://wcrp-cmip.github.io/CMIP7_CVs/\",\n                    \"wcrp-universe\": \"https://wcrp-cmip.github.io/WCRP-universe/\"\n\n                    // define information for fields which may be linked. \n                    \"activity\": {\n                                    \"@context\": \"https://wcrp-cmip.github.io/WCRP-universe/activity/_context_\",\n                                    \"@type\": \"@id\",\n                            }\n    },\n\n    // framing options go here, e.g. expand all links\n    \"@embed\": \"@always\"\n}\n</code></pre> The <code>_context_</code> files in our repositories are used both to define additional <code>@context</code> information, and to provide a basic framing context should that be required by the user. </p>"},{"location":"What_is_JSONLD%3F/Background/#other-changes-to-the-cvs","title":"Other changes to the CVs","text":""},{"location":"What_is_JSONLD%3F/Background/#file-hierarchy","title":"File hierarchy","text":"<p>Instead of having one large file containing all possible sources/experiments/institutions etc., we will break these out into individual json files. </p> <p>This serves to improve the workflow and usability of the directories in several ways: </p> <ol> <li>A better understanding of changes over time. This way we are able to create a difference log for an individual item, without having to track the entire collection or category.</li> <li>Error isolation A mistake in a single file will not affect any of the others, and will allow us to easier identify it. </li> <li>Versioning The changes in each file are tracked, and we know exactly when they have occured. </li> <li>Line identification It will be easier to hilight a file or specific line, without the worry that an issue 2 weeks old will now refer to something else. </li> <li>ATTRIBUTION by seeing who is contributing changes to certain files will allow us to credit prominent members of the community, and generate a list of specialists for specific topics should there be any queries at a later point. </li> </ol>"},{"location":"What_is_JSONLD%3F/Defining_the_context/","title":"Defining the context","text":""},{"location":"What_is_JSONLD%3F/Defining_the_context/#example-uses-for-jsonld-and-how-they-may-be-defined-in-the-context","title":"Example uses for JSONLD and how they may be defined in the context.","text":"<p>For locations of the context see:  Where do we store the context.</p>"},{"location":"What_is_JSONLD%3F/Defining_the_context/#specifying-links-in-json-ld-and-context-representations","title":"Specifying Links in JSON-LD and Context Representations","text":""},{"location":"What_is_JSONLD%3F/Defining_the_context/#1-use-id","title":"1. Use <code>@id</code>","text":"<p>The simplest way to define an item is to use the resource's unique identifier: <pre><code>{\n  \"@id\": \"https://wcrp-cmip.org/resource\"\n}\n</code></pre></p>"},{"location":"What_is_JSONLD%3F/Defining_the_context/#2-using-a-named-term","title":"2. Using a Named Term","text":"<p>We can also map a term e.g. <code>id</code> -&gt; <code>@id</code> making the file clearer to a non-technical user. </p> <pre><code>{\n        \"id\": \"https://wcrp-cmip.org/resource\"\n}\n</code></pre> <pre><code>{\n        \"@context\": {\n                    \"id\": \"@id\"\n        }\n}\n</code></pre>"},{"location":"What_is_JSONLD%3F/Defining_the_context/#3-array-of-ids","title":"3. Array of IDs","text":"<p>We may define multiple IDs to a single property</p> <pre><code>{\n        \"related\": [\n                    \"https://wcrp-cmip.org/resource1\",\n                    \"https://wcrp-cmip.org/resource2\"\n        ]\n}\n</code></pre> <pre><code>{\n  \"@context\": {\n            \"related\": {\n                    \"@container\": \"@id\"\n            }\n  }\n}\n</code></pre>"},{"location":"What_is_JSONLD%3F/Defining_the_context/#4-compact-representation-of-ids","title":"4. Compact Representation of IDs","text":"<p>We are also able to use a shortened version of the id by using a prefix. </p> <pre><code>{\n         \"resource\": \"example:onlyoffice\"\n}\n</code></pre> <pre><code>{\n        \"@context\": {\n                \"example\": \"http://wcrp-cmip.org/\"\n        }\n}\n</code></pre> <p>This may also be defined implicitly using the <code>@vocab</code> in the global context, or locally in the case where the referenced items have  different paths to the current file. </p> <pre><code>{\n         \"resource\": \"onlyoffice\"\n}\n</code></pre> <pre><code>{\n        \"@context\": {\n                \"resource\":{ \n                            \"@context\": {\n                                \"@vocab\":\"http://wcrp-cmip.org/\",\n                                \"@type\":\"@id\"\n                            }\n                }\n        }\n}\n</code></pre>"},{"location":"What_is_JSONLD%3F/Example_usage/Defining_the_context/","title":"Defining the context","text":""},{"location":"What_is_JSONLD%3F/Example_usage/Defining_the_context/#example-uses-for-jsonld-and-how-they-may-be-defined-in-the-context","title":"Example uses for JSONLD and how they may be defined in the context.","text":"<p>For locations of the context see:  the _context_ file</p>"},{"location":"What_is_JSONLD%3F/Example_usage/Defining_the_context/#specifying-links-in-json-ld-and-context-representations","title":"Specifying Links in JSON-LD and Context Representations","text":""},{"location":"What_is_JSONLD%3F/Example_usage/Defining_the_context/#1-use-id","title":"1. Use <code>@id</code>","text":"<p>The simplest way to define an item is to use the resource's unique identifier: <pre><code>{\n  \"@id\": \"https://wcrp-cmip.org/resource\"\n}\n</code></pre></p>"},{"location":"What_is_JSONLD%3F/Example_usage/Defining_the_context/#2-using-a-named-term","title":"2. Using a Named Term","text":"<p>We can also map a term e.g. <code>id</code> -&gt; <code>@id</code> making the file clearer to a non-technical user. </p> <pre><code>{\n        \"id\": \"https://wcrp-cmip.org/resource\"\n}\n</code></pre> <pre><code>{\n        \"@context\": {\n                    \"id\": \"@id\"\n        }\n}\n</code></pre>"},{"location":"What_is_JSONLD%3F/Example_usage/Defining_the_context/#3-array-of-ids","title":"3. Array of IDs","text":"<p>We may define multiple IDs to a single property</p> <pre><code>{\n        \"related\": [\n                    \"https://wcrp-cmip.org/resource1\",\n                    \"https://wcrp-cmip.org/resource2\"\n        ]\n}\n</code></pre> <pre><code>{\n  \"@context\": {\n            \"related\": {\n                    \"@container\": \"@id\"\n            }\n  }\n}\n</code></pre>"},{"location":"What_is_JSONLD%3F/Example_usage/Defining_the_context/#4-compact-representation-of-ids","title":"4. Compact Representation of IDs","text":"<p>We are also able to use a shortened version of the id by using a prefix. </p> <pre><code>{\n         \"resource\": \"example:onlyoffice\"\n}\n</code></pre> <pre><code>{\n        \"@context\": {\n                \"example\": \"http://wcrp-cmip.org/\"\n        }\n}\n</code></pre> <p>This may also be defined implicitly using the <code>@vocab</code> in the global context, or locally in the case where the referenced items have  different paths to the current file. </p> <pre><code>{\n         \"resource\": \"onlyoffice\"\n}\n</code></pre> <pre><code>{\n        \"@context\": {\n                \"resource\":{ \n                            \"@context\": {\n                                \"@vocab\":\"http://wcrp-cmip.org/\",\n                                \"@type\":\"@id\"\n                            }\n                }\n        }\n}\n</code></pre>"}]}